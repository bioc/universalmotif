% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sequence_complexity.R
\name{sequence_complexity}
\alias{sequence_complexity}
\title{Calculate sequence complexity.}
\usage{
sequence_complexity(seqs, window.size = 20,
  window.overlap = round(window.size/2), method = c("WoottonFederhen",
  "WoottonFederhenFast", "Trifonov", "TrifonovFast", "DUST"),
  trifonov.max.word.size = 7, nthreads = 1, return.granges = FALSE)
}
\arguments{
\item{seqs}{\code{\link{XStringSet}} Input sequences.}

\item{window.size}{\code{numeric} Window size. If a number between 0 and 1 is
provided, the value is calculated as the number multiplied by the sequence
length.}

\item{window.overlap}{\code{numeric} Overlap between windows. If a number
between 0 and 1 is provided, the value is calculated as the number
multiplied by the sequence length.}

\item{method}{\code{character(1)} Choose one of the available methods for calculating
sequence complexity. See details.}

\item{trifonov.max.word.size}{\code{numeric(1)} The maximum word size within each window
used to calculate complexity using \code{method = c("Trifonov", "TrifonovFast")}.
In other words, the Trifonov method involves counting the number of possible
different sub-words in a window at different sizes up to the values provided
by this option. It also involves calculating the product of ever increasing
sequences of numbers and so in order to reduce the computations involed
this can be limited to a specific maximum sub-word size.}

\item{nthreads}{\code{numeric(1)} Run \code{\link[=sequence_complexity]{sequence_complexity()}} in parallel with \code{nthreads}
threads. \code{nthreads = 0} uses all available threads.}

\item{return.granges}{\code{logical(1)} Return the results as a \code{GRanges} object.
Requires the \code{GenomicRanges} package to be installed.}
}
\value{
\code{DataFrame}, \code{GRanges} with each row getting a complexity score for
each window in each input sequence.
}
\description{
Calculate sequence complexity using either the Wootton-Federhen, Trifonov,
or DUST algorithms.
}
\details{
The Wootton-Federhen (Wootton and Federhen, 1993) and Trifonov (Trifonov,
1990) algorithms as well as their faster approximations are well described
within Orlov and Potapov (2004). These algorithms score less complex sequences
closer to 0, and more complex ones closer to 1. Please note that the
'fast' approximation versions of the two methods are not actually faster
within \code{\link[=sequence_complexity]{sequence_complexity()}}, and so speed should not be a major consideration
when choosing which method to use within the \code{universalmotif} package.
The DUST algorithm
implementation is described in Morgulis et al. (2006). In this case,
less complex sequences score higher, and more complex ones closer
to 0.

Please note that the authors of the different methods recommend various
window sizes and complexity thresholds. The authors of DUST for example,
suggest using a window size of 64 and a threshold of 2 for low complexity.
Wootton and Federhen suggest a window size of 40, though show that 10
and 20 can be appropriate as well.
}
\examples{
## Feel free to play around with different toy sequences to get a feel for
## how the different methods perform

library(Biostrings)
test.seq <- DNAStringSet(c("AAAAAAAAAAA", "ATGACTGATGC"))

sequence_complexity(test.seq, method = "WoottonFederhen")
sequence_complexity(test.seq, method = "WoottonFederhenFast")
sequence_complexity(test.seq, method = "Trifonov")
sequence_complexity(test.seq, method = "TrifonovFast")
sequence_complexity(test.seq, method = "DUST")

## You could also use this in conjuction with mask_ranges() to hide
## low complexity regions from scanning, de novo motif discovery, etc

if (requireNamespace("GenomicRanges", quiet = TRUE)) {
data(ArabidopsisPromoters)

# Calculate complexity in 20 bp windows, sliding every 1 bp
to.mask <- sequence_complexity(ArabidopsisPromoters, method = "DUST",
  window.size = 20, window.overlap = 19, return.granges = TRUE)

# Get the ranges with a complexity score greater than 3.5
to.mask <- to.mask[to.mask$complexity > 3.5]

# See what the low complexity regions look like
ArabidopsisPromoters[IRanges::reduce(to.mask)]

# Mask them with the '-' character:
mask_ranges(ArabidopsisPromoters, to.mask)
}

}
\references{
Morgulis A, Gertz EM, Schaffer AA, Agarwala R (2006). "A fast and symmetric
DUST implementation to mask low-complexity DNA sequences." \emph{Journal of
Computational Biology}, \strong{13}, 1028-1040.

Orlov YL, Potapov VN (2004). "Complexity: an internet resource for analysis
of DNA sequence complexity." \emph{Nucleic Acids Research}, \strong{32}, W628-W633.

Trifonov EN (1990). "Making sense of the human genome." In Sarma RH, Sarma
MH (Eds), \emph{Structure & Methods} Adenine Press, Albany, \strong{1}, 69-77.

Wootton JC, Federhen S (1993). "Statistics of local complexity in amino acid
sequences and sequence databses." \emph{Computers & Chemistry}, \strong{17}, 149-163.
}
\seealso{
\code{\link[=count_klets]{count_klets()}}, \code{\link[=get_bkg]{get_bkg()}}, \code{\link[=mask_ranges]{mask_ranges()}}, \code{\link[=mask_seqs]{mask_seqs()}}
}
\author{
Benjamin Jean-Marie Tremblay, \email{benjamin.tremblay@uwaterloo.ca}
}
